<html>
  <head>
      <title> Codes </title>
  </head>
  <body>
      <h2> Rabin Karp Algorithm - Fix Bug </h2>
      <p> Given a text T and a pattern P, implement the Rabin-Karp algorithm to print all occurrences of P in T. Assume that only digits will be given as input. For example, if T is "235902314152673992" and P is "31415", then print the indices of occurrences (programming index). </p>
      <p> Note: The code given has a bug, fix it. </p>

      <p> Input Format: </p>
      <ul>
        <li> First line contains the text, T </li>
        <li> Next line contains the pattern, P </li>
      </ul>

      <p> Output Format: </p>
      <ul>
        <li> Print all indices of occurrence of P in T </li>
        <li> Print one index per line </li>
      </ul>

      <h3> Code: </h3>
      <pre>
#include <iostream>
using namespace std;
#include <string>
#include <cmath>

int valueOf(char ch) {
    return (ch - '0');
}

bool check_characters(string T, string P, int s) {
    int n = T.length();
    int m = P.length();
    for (int i = 0; i < m; i++) {
        if (P[i] != T[s + i])
            return false;
    }
    return true;
}

void rabin_karp_matcher(string T, string P, int d, int q) {
    int n = T.length();
    int m = P.length();
    int h = (int)pow(d, m - 1) % q;
    cout << "h value is " << h << endl;
    int p = 0, t0 = 0;
    
    for (int i = 0; i < m; i++) {
        p = (d * p + valueOf(P[i])) % q;
        t0 = (d * t0 + valueOf(T[i])) % q;
    }
    
    for (int s = 0; s <= n - m; s++) {
        cout << p << " " << t0 << endl;
        if (p == t0) {
            if (check_characters(T, P, s)) {
                cout << s + 1 << endl;
            }
        }
        if (s < n - m) {
            t0 = (d * (t0 - valueOf(T[s]) * h) + valueOf(T[s + m])) % q;
            if (t0 < 0) {
                t0 += q;
            }
        }
    }
}

int main() {
    string T, P;
    int d, q;
    cin >> T >> P;
    cin >> d >> q;
    rabin_karp_matcher(T, P, d, q);
}
      </pre>

      <h2> Naive String Matching without Overlapping </h2>
      <p> Given a text T and a pattern P, implement the naive algorithm to print the non-overlapping positions of P in T. For example, if T is "aaaaaaaa" and pattern is "aa", the code should print 0, 2, 4, 6 (programming indices - non-overlapping). </p>

      <p> Input Format: </p>
      <ul>
        <li> First line contains the text, T </li>
        <li> Next line contains the pattern, P </li>
      </ul>

      <p> Output Format: </p>
      <ul>
        <li> Print non-overlapping indices, one value per line </li>
      </ul>

      <h3> Code: </h3>
      <pre>
#include<iostream>
using namespace std;
#include<string>

bool check_pattern(string T, string P, int s) {
    int m = P.length();
    for (int i = 0; i < m; i++) {
        if (P[i] != T[s + i])
            return false;
    }
    return true;
}

void naive_string_matcher(string T, string P) {
    int n = T.length();
    int m = P.length();

    for (int s = 0; s <= n - m; s++) {
        if (check_pattern(T, P, s)) {
            cout << s << endl;
            T[s + m - 1] = '*'; // Mark this part to avoid overlapping
        }
    }
}

int main() {
    string T, P;
    cin >> T >> P;
    naive_string_matcher(T, P);
}
      </pre>

      <h2> Love Diagonal Hate 3 Queen Game </h2>
      <p> The Love Diagonal Hate 3 Queen Game is a board game in which we have to place min(m, n) queens on an mXn rectangular board. The rows and columns are numbered from 1 to m and 1 to n respectively. We cannot place a queen on a cell if the sum of their row and column indices is divisible by 3 (i.e., queens cannot be placed on cells with indices like (1, 2), (5, 1), etc.). In this game, a queen is attacked by another queen if they are on the same row or on the same column. </p>
      <p> Given the dimensions of the board, develop a recursive algorithm using a backtracking technique to find the number of different solutions. </p>

      <p> Input Format: </p>
      <ul>
        <li> First line contains the number of rows in the rectangular board, m </li>
        <li> Next line contains the number of columns in the rectangular board, n </li>
      </ul>

      <p> Output Format: </p>
      <ul>
        <li> Print the number of solutions </li>
      </ul>

      <h3> Code: </h3>
      <pre>
#include <iostream>
#include <vector>
using namespace std;

int count = 0;

bool isSafe(int row, int col, vector<int>& cols) {
    if ((row + col + 2) % 3 == 0) {
        return false;
    }
    if (cols[col] == 1) {
        return false;
    }
    return true;
}

void nqueens(int row, int queensplaced, int m, int n, int numqueens, vector<vector<int>>& board, vector<int>& cols) {
    if (queensplaced == numqueens) {
        count++;
        return;
    }
    if (row == m) {
        return;
    }
    for (int i = 0; i < n; i++) {
        if (isSafe(row, i, cols)) {
            board[row][i] = 1;
            cols[i] = 1;
            nqueens(row + 1, queensplaced + 1, m, n, numqueens, board, cols);
            board[row][i] = 0;
            cols[i] = 0;
        }
    }
    nqueens(row + 1, queensplaced, m, n, numqueens, board, cols);
}

int solve(int m, int n) {
    int q = min(m, n);
    vector<vector<int>> board(m, vector<int>(n, 0));
    vector<int> cols(n, 0);
    nqueens(0, 0, m, n, q, board, cols);
    return count;
}

int main() {
    int m, n;
    cin >> m;
    cin >> n;
    cout << solve(m, n);
}
      </pre>
  </body>
</html>
